---
description: Best practices and utilities for SwiftUI previews in Agora (iOS 26). Use this when creating/updating Previews, building preview-only data, or verifying UI across Dev/Staging/Prod. Guarantees: no live network, deterministic UI, quick refresh.
alwaysApply: false
---

## SwiftUI Previews — Agora Standard (iOS 26)

### Goals

1. See Dev / Staging / Prod variants side-by-side via `#Preview`, while the app continues to use compile-time configs at runtime
2. Keep previews safe (no live calls) and deterministic (fonts, locale, device)
3. Make Snapshots and Previews consistent

### 0) Schemes & Flags (must-fix)

**Owner: iOS Platform**

Create a third scheme:
- `Agora Dev` → Run = Debug (uses `DEV_ENVIRONMENT`)
- `Agora Staging` → Run = Staging (uses `STAGING_ENVIRONMENT`)
- `Agora` (Prod) → Run = Release (uses `PROD_ENVIRONMENT`)

**Current issue:** Production scheme is using `STAGING_ENVIRONMENT`. Fix `SWIFT_ACTIVE_COMPILATION_CONDITIONS` for "Agora".

#### Verification (paste into terminal)

```bash
xcodebuild -scheme "Agora" -showBuildSettings | sed -n 's/^ *SWIFT_ACTIVE_COMPILATION_CONDITIONS = //p'
xcodebuild -scheme "Agora Staging" -showBuildSettings | sed -n 's/^ *SWIFT_ACTIVE_COMPILATION_CONDITIONS = //p'
# after creating:
xcodebuild -scheme "Agora Dev" -showBuildSettings | sed -n 's/^ *SWIFT_ACTIVE_COMPILATION_CONDITIONS = //p'
```

### 1) Environment selection in previews (non-invasive)

We'll keep your runtime detection (`AppConfig.isDevelopment`/`.isStaging`) and introduce a preview-only override via a SwiftUI environment value.

#### Add file: `AppFoundation/AppEnvironment.swift`

```swift
import SwiftUI

public enum AppEnvironment: Equatable, Sendable {
    case dev, staging, prod
}

public enum EnvironmentConfig {
    /// Compile-time default: do NOT change runtime behavior.
    public static var compiledDefault: AppEnvironment {
        #if DEV_ENVIRONMENT
        return .dev
        #elseif STAGING_ENVIRONMENT
        return .staging
        #else
        return .prod
        #endif
    }

    /// Convenience: bridge your existing AppConfig into an explicit env when needed.
    public static func fromRuntime() -> AppEnvironment {
        if AppConfig.isDevelopment { return .dev }
        if AppConfig.isStaging { return .staging }
        return .prod
    }

    // Example helpers; call into your existing AppConfig/Info.plist logic if you prefer.
    public static func apiBaseURL(for env: AppEnvironment) -> String {
        switch env {
        case .dev:     return "https://api-dev.agora.com"
        case .staging: return "https://api-staging.agora.com"
        case .prod:    return "https://api.agora.com"
        }
    }
}

/// SwiftUI key to *override* environment in previews (defaults to compiled value).
private struct AppEnvironmentKey: EnvironmentKey {
    static let defaultValue: AppEnvironment = EnvironmentConfig.compiledDefault
}

public extension EnvironmentValues {
    var appEnvironment: AppEnvironment {
        get { self[AppEnvironmentKey.self] }
        set { self[AppEnvironmentKey.self] = newValue }
    }
}
```

#### Usage in views (opt-in where you need env-dependent behavior)

```swift
import SwiftUI

struct ExampleView: View {
    @Environment(\.appEnvironment) private var appEnv
    @Environment(\.deps) private var deps  // your existing DI

    var body: some View {
        VStack(spacing: 8) {
            Text("Env: \(String(describing: appEnv).uppercased())")
            Text("API: \(EnvironmentConfig.apiBaseURL(for: appEnv))")
        }
        .padding()
    }
}
```

### 2) Multi-environment #Previews (side-by-side)

#### Add file: `AppUI/PreviewSupport/Preview+Env.swift`

```swift
import SwiftUI

/// Shorthand helpers for clarity in #Preview blocks
public extension View {
    func previewEnv(_ env: AppEnvironment) -> some View {
        self.environment(\.appEnvironment, env)
    }

    /// Optional visual watermark so designers/QA can tell which env they're seeing.
    func previewEnvBadge(_ label: String) -> some View {
        self.overlay(alignment: .topTrailing) {
            Text(label)
                .font(.caption2.monospaced())
                .padding(6)
                .background(.thinMaterial, in: Capsule())
                .padding(6)
        }
    }
}
```

#### In any view's preview file

```swift
#Preview("Dev") {
    ExampleView()
        .environment(\.deps, .preview)       // you already have this
        .previewEnv(.dev)
        .previewEnvBadge("DEV")
}

#Preview("Staging") {
    ExampleView()
        .environment(\.deps, .preview)
        .previewEnv(.staging)
        .previewEnvBadge("STAGING")
}

#Preview("Prod") {
    ExampleView()
        .environment(\.deps, .preview)
        .previewEnv(.prod)
        .previewEnvBadge("PROD")
}
```

**Result:** one canvas refresh renders all three environments—no runtime changes to the app.

### 3) Centralized Preview Scenarios (canonical states)

Create a tiny catalog for realistic, reusable data (no live I/O).

**Folder:** `AppUI/PreviewSupport/Scenarios/`

#### Example: `AppUI/PreviewSupport/Scenarios/PreviewScenarios.swift`

```swift
import Foundation

public enum PreviewScenario: String, CaseIterable, Sendable {
    case emptyFeed
    case lightEngagement
    case heavyEngagement
    case authLoggedOut
}

public struct PreviewData: Sendable {
    public var posts: [Post] = []
    public var currentUser: User? = nil
    public var isLoggedIn: Bool = true
}

public enum PreviewScenarios {
    public static func make(_ scenario: PreviewScenario) -> PreviewData {
        switch scenario {
        case .emptyFeed:
            return PreviewData(posts: [], currentUser: .mock(), isLoggedIn: true)
        case .lightEngagement:
            return PreviewData(posts: Post.mocks(count: 5), currentUser: .mock(), isLoggedIn: true)
        case .heavyEngagement:
            return PreviewData(posts: Post.mocks(count: 50), currentUser: .mockPowerUser(), isLoggedIn: true)
        case .authLoggedOut:
            return PreviewData(posts: [], currentUser: nil, isLoggedIn: false)
        }
    }
}
```

#### Wire scenarios into your DI

You already have `Dependencies.preview`:

```swift
import SwiftUI

public extension Dependencies {
    static func preview(scenario: PreviewScenario) -> Dependencies {
        var d = Dependencies.preview  // your existing fake deps baseline
        let data = PreviewScenarios.make(scenario)
        d.auth = MockAuthService(isLoggedIn: data.isLoggedIn, user: data.currentUser)
        d.api  = StubAgoraClient(posts: data.posts)  // reuse your stub types
        return d
    }
}
```

#### Use in previews

```swift
#Preview("Empty Feed – Dev") {
    HomeView()
        .environment(\.deps, .preview(scenario: .emptyFeed))
        .previewEnv(.dev)
        .previewEnvBadge("DEV · EMPTY FEED")
}
```

### 4) Determinism & Safety Rules

1. **Never perform live I/O in previews.** Use `Dependencies.preview`/scenarios only.

2. **Pin determinism:**
   - Use fixed device: `.previewDevice("iPhone 17 Pro")`
   - Force size category/appearance if relevant:
     ```swift
     .environment(\.sizeCategory, .medium)
     .environment(\.locale, .init(identifier: "en_US"))
     .preferredColorScheme(.light)
     ```

3. **Avoid `.task`/timers doing real work in previews;** guard with `if isPreview { … }` if necessary.

4. **Keep heavy mock graphs behind previews only;** don't ship them in prod builds (OK to leave in Debug).

5. **(Optional)** If you want a compile-time guard for preview-only code, add:
   - `Debug.xcconfig`: `OTHER_SWIFT_FLAGS = $(inherited) -DPREVIEW_BUILD`
   - Then gate heavy code with `#if PREVIEW_BUILD`.

### 5) SnapshotTesting alignment

Standardize how a view is created for both previews and snapshots.

#### Add: `Tests/TestSupport/ViewFactory.swift`

```swift
import SwiftUI
@testable import Agora

enum ViewFactory {
    static func homeView(env: AppEnvironment, scenario: PreviewScenario) -> some View {
        HomeView()
            .environment(\.deps, .preview(scenario: scenario))
            .environment(\.appEnvironment, env)
            .frame(width: 390, height: 844) // iPhone 17 Pro logical size
            .environment(\.locale, .init(identifier: "en_US"))
            .preferredColorScheme(.light)
    }
}
```

#### Use in a snapshot

```swift
func testHome_light_dev_emptyFeed() {
    let view = ViewFactory.homeView(env: .dev, scenario: .emptyFeed)
    assertSnapshot(of: view)  // adapt to your SnapshotTesting API wrapper
}
```

**Benefit:** previews and snapshots use the same construction path, reducing "works in preview but not in tests."

### 6) Visual Environment Indicators

To make env obvious in UI mocks, optionally add a tiny banner for non-prod:

#### Add: `AppUI/PreviewSupport/EnvBanner.swift`

```swift
import SwiftUI

public struct EnvironmentBanner: View {
    @Environment(\.appEnvironment) private var env

    public init() {}

    public var body: some View {
        Group {
            switch env {
            case .prod:
                EmptyView()
            case .dev:
                Label("DEV", systemImage: "hammer.fill")
            case .staging:
                Label("STAGING", systemImage: "shippingbox.fill")
            }
        }
        .font(.caption2.monospaced())
        .padding(6)
        .background(.thinMaterial, in: Capsule())
        .padding(6)
    }
}

public extension View {
    func attachEnvBanner() -> some View {
        self.overlay(alignment: .topLeading) { EnvironmentBanner() }
    }
}
```

#### Usage

```swift
HomeView()
  .environment(\.deps, .preview)
  .previewEnv(.staging)
  .attachEnvBanner()
```

### 7) PR Checklist (previews)

- [ ] No live I/O in `#Previews` (uses `Dependencies.preview` or `.preview(scenario:)`)
- [ ] At least one multi-env preview (Dev/Staging/Prod) for env-sensitive UI
- [ ] Deterministic settings (device, color scheme, locale, size category) for complex views
- [ ] If new mock data added → placed in `PreviewScenarios` (not scattered)
- [ ] If Snapshot added → uses `ViewFactory` construction matching previews
- [ ] No production-only secrets/keys referenced in Preview code
- [ ] (If applicable) watermarks/badges attached for clarity

### 8) Migration To-Dos (Jira-sliceable)

- [ ] Fix scheme flags so "Agora" uses `PROD_ENVIRONMENT`; add "Agora Dev".
- [ ] Add `AppFoundation/AppEnvironment.swift`.
- [ ] Add `AppUI/PreviewSupport/Preview+Env.swift` (env override + badge).
- [ ] Create `AppUI/PreviewSupport/Scenarios/` with `PreviewScenarios.swift`.
- [ ] Add `Tests/TestSupport/ViewFactory.swift` and convert 1 canary snapshot to use it.
- [ ] Update 2–3 high-traffic views to include three `#Preview` blocks (Dev/Staging/Prod) with `.environment(\.deps, .preview(scenario: …))`.
- [ ] (Optional) Add `EnvBanner` and apply to feed/profile previews.

### Notes tailored to your setup

1. You already have `Dependencies.preview`, `StubAgoraClient`, and `AnalyticsClientFake`—perfect. The rule above just centralizes how they're used with scenarios and adds the env override in a Swifty, non-invasive way.

2. Swift packages won't see `DEV_ENVIRONMENT` etc.—that's fine; previews should pass env via `EnvironmentValues`, not rely on package compilation flags.

3. This doesn't change your runtime logic (bundle-ID detection + Info.plist injection) and doesn't risk shipping a debug env to prod.
