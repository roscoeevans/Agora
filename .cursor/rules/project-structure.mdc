---
description: Authoritative module placement & dependency contract for Agora iOS (SPM-first, iOS-only). Defines where code lives and how modules communicate.
alwaysApply: true
globs:
  - "Packages/**"
  - "Resources/**"
  - "Tools/**"
lint:
  failOn:
    - "forbidden-imports"
    - "route-file-location"
    - "designsystem-service-access"
    - "feature-to-feature-dep"
    - "models-usage"
    - "platform-guards"
    - "uikit-isolation"
---
## Agora iOS Project Structure

### Overview

This rule defines where files and code belong in the Agora iOS app's Swift Package Manager (SPM) modular architecture. Use this when creating new files, features, or modules to ensure correct placement.

### Root Directory Structure

```
Agora/
├── Agora.xcodeproj/           # Main Xcode project
├── AgoraTests/                # Main app unit tests
├── AgoraUITests/              # Main app UI tests
├── database/                  # Supabase migrations and schema
├── docs/                      # Project documentation
├── OpenAPI/                   # API specifications (see configuration.mdc)
├── Packages/                  # Swift Package modules (see below)
├── Resources/                 # App resources and main app files
├── Scripts/                   # Legacy CI/test scripts (most replaced by agctl)
├── supabase/                  # Supabase Edge Functions
├── Tests/                     # Cross-module snapshot/UI tests
├── Tools/                     # Development tools (agctl CLI)
└── Package.swift              # Root package manifest
```

### Packages Directory Structure

The `Packages/` directory is organized into **four main categories**:

#### Features (`Packages/Features/`)
**When to use:** Creating user-facing features that represent distinct app functionality

```
Features/
├── Auth/                      # Auth UI/UX + app-level state (services are in AppFoundation)
├── Compose/                   # Post composition and media upload
├── DirectMessages/            # Direct messaging (DMs)
├── HomeFollowing/             # Following feed (chronological)
├── HomeForYou/                # For You feed (recommendations)
├── Notifications/             # Push notifications and in-app alerts
├── PostDetail/                # Individual post viewing
├── Profile/                   # User profiles and settings
├── Search/                    # People and content search
└── Threading/                 # Reply threads and conversations
```

**Feature modules contain:**
- SwiftUI views and view models
- Feature-specific business logic
- Feature-level coordinators and state management
- Dependencies on Kits and Shared modules

**Important:** Feed switching (For You ↔ Following) lives in `Resources/RootView.swift` at the app root level, not in a separate feature package. This is app-level orchestration, not feature-specific business logic. Features should be isolated and independent; avoid creating "coordinator" features that just combine other features.

**Composition Rules:**
- Composition lives at app root (`Resources/RootView.swift` and Root composition) or in AppFoundation Navigation
- Features remain leaf packages
- Features never push other Features directly. They emit intents/route requests (via AppFoundation types). App root (or Nav env) performs the cross-tab navigation.

#### Kits (`Packages/Kits/`)
**When to use:** Creating reusable functionality that provides specific capabilities

```
Kits/
├── Analytics/                 # PostHog analytics wrapper
├── DesignSystem/              # UI components, colors, typography
├── Engagement/                # Post engagement (likes, reposts, shares)
├── Media/                     # Image/video capture, processing, upload
├── Moderation/                # Content moderation and reporting
├── Networking/                # API client and network layer (OpenAPI)
├── Persistence/               # SwiftData models and caching
├── Recommender/               # Recommendation engine client
├── SupabaseKit/               # Supabase services wrapper (auth, realtime, storage)
└── Verification/              # Device attestation and anti-bot
```

**Kit modules contain:**
- Service protocols and implementations
- Reusable business logic
- Third-party SDK wrappers
- Dependencies on other Kits and Shared modules

**Key Kit Guidelines:**
- **SupabaseKit**: PostgREST/Realtime/Auth/Storage/Edge Functions for Supabase. Never host OpenAPI clients here.
- **Networking**: OpenAPI client and non-Supabase HTTP/WS. Never import Supabase from here.
- **DesignSystem**: UI components only (value-types + views)
  - Allowed imports: SwiftUI, Foundation, CoreGraphics
  - Conditional: UIKit under `#if os(iOS)` for haptics/rendering only
  - May import AppFoundation value types (tokens, ID newtypes)
  - **MUST NOT** access services or `@Environment(\.deps)`
  - No business logic; no service classes/actors
- **Engagement**: Business logic for post interactions - protocols defined in AppFoundation (`ServiceProtocols.swift`)
- **Recommender**: Client wrapper for server-driven ranking only. No heuristic/scoring models.

**Important:** Authentication services (Sign in with Apple, phone verification, session management) live in `AppFoundation`, not as a Kit. See "Why Authentication Lives in AppFoundation" below.

#### Shared (`Packages/Shared/`)
**When to use:** Creating cross-cutting concerns and utilities used everywhere

```
Shared/
├── AppFoundation/             # Core app utilities and services
└── TestSupport/               # Testing utilities and mocks
```

**AppFoundation contains:**
- Environment detection and configuration (`Environment.swift`, `AppConfig.swift`)
- Dependency injection (`Dependencies.swift`, `Dependencies+Environment.swift`)
- Navigation infrastructure (`Routes.swift`, `DeepLinkRouter.swift`, `NavigationEnvironment.swift`)
- Appearance preferences (`AppearancePreference.swift`)
- **Service protocols** (`ServiceProtocols.swift`) - All service interfaces defined here
- Auth services (`SupabaseAuthService.swift`, `SessionStore.swift`, `KeychainHelper.swift`)
- Phone verification (`TwilioPhoneVerifier.swift`)
- Mock implementations (`MockServices.swift`)
- Service factories (`ServiceFactory.swift`)

**Critical:** AppFoundation defines service protocols, but implementations live in their respective Kits. This prevents circular dependencies and enables clean testing.

**Exception:** Auth implementations live in Shared/AppFoundation due to lifecycle coupling (bootstrap, session, environment). Any future candidate for AppFoundation implementation must be formally reviewed; the default is: implementations live in Kits.

#### ThirdParty (`Packages/ThirdParty/`)
**When to use:** Integrating third-party SDKs that need custom Swift Package wrappers

```
ThirdParty/
├── hCaptcha/                  # hCaptcha challenge SDK
├── OneSignal/                 # Push notification service
├── PostHog/                   # Analytics SDK
└── Sentry/                    # Crash reporting SDK
```

**Use ThirdParty when:**
- SDK doesn't support SPM natively
- Need to wrap SDK in protocol interface
- Custom integration logic required

### Decision Tree: Where Does X Go?

#### "I'm creating a new view/screen"
→ **Feature module** in `Packages/Features/`
- If it's part of an existing feature, add to that feature's package
- If it's a new major feature, create a new Feature package

#### "I'm creating a reusable UI component"
→ **DesignSystem Kit** in `Packages/Kits/DesignSystem/`
- Buttons, cards, text styles, colors, etc.

#### "I'm creating a service/client"
→ **Kit module** in `Packages/Kits/`
- If it's auth-related → **AppFoundation** (`Shared/AppFoundation`)
- If it's a new capability → Create new Kit or add to existing Kit

#### "I'm creating app-wide utilities"
→ **AppFoundation** in `Packages/Shared/AppFoundation/`
- Extensions, helpers, configuration, DI infrastructure

#### "I'm creating test utilities"
→ **TestSupport** in `Packages/Shared/TestSupport/`
- Mock implementations, test fixtures, shared test helpers

#### "I'm creating navigation routes"
→ **AppFoundation** in `Packages/Shared/AppFoundation/Routes.swift`
- Tab-level routes (FeedRoute, SearchRoute, etc.)
- Deep link parsing logic

#### "I'm integrating a third-party SDK"
- If available via SPM → Add to Package.swift dependencies
- If needs custom wrapper → **ThirdParty** in `Packages/ThirdParty/`

### ThirdParty Wrapping Policy

**Wrap if:**
- SDK has no SPM/binary vendoring support, OR
- Vendor API needs protocol abstraction to avoid type leakage, OR
- Requires platform gating or centralized config injection

**Otherwise:** Depend on vendor directly **from the consuming Kit** (not from Features).

#### "I'm creating a service that other modules need"
- Define protocol in **AppFoundation** (`ServiceProtocols.swift`)
- Implement in appropriate **Kit** module
- Register in **Dependencies** container
- Example: `CommentCompositionProtocol` in AppFoundation, `CommentCompositionService` in PostDetail

#### "I'm adding bookmarking/collections"
→ **Kit** (domain logic) + small **Feature** for UI, protocols in AppFoundation

#### "I'm adding local caching or persistence"
→ **Persistence Kit**; define models here, expose read/write interfaces; do not put SwiftData code in Features.

#### "I'm creating a Supabase wrapper"
- Create new **SupabaseKit** module
- Define protocols for Supabase services
- Implement live and mock versions
- Other modules can depend on SupabaseKit directly

### Package Structure Template

Every Swift Package must follow this structure:

```
PackageName/
├── Package.swift              # Package manifest (see module-standards.mdc)
├── README.md                  # Package documentation
├── Sources/
│   └── PackageName/           # Source code (matches package name exactly)
│       ├── PackageName.swift  # Main public interface
│       └── [other files]      # Implementation files
└── Tests/
    └── PackageNameTests/      # Test files
        └── PackageNameTests.swift
```

**Critical naming rule:** The `Sources/PackageName/` directory name must **exactly match** the package name in `Package.swift`.

### File Naming Conventions

#### Swift Files
- **Views:** `{Feature}View.swift` (e.g., `ComposeView.swift`)
- **ViewModels:** `{Feature}ViewModel.swift` (e.g., `ComposeViewModel.swift`)
- **Models:** `{Feature}.swift` or `{Feature}Model.swift`
- **Business Logic Services:** `{Service}Service.swift` / `{Service}ServiceLive.swift` / `{Service}ServiceMock.swift`
- **Network Clients:** `{Client}Client.swift` / `{Client}ClientLive.swift` / `{Client}ClientMock.swift`
- **Test Mocks:** `{Service}Mock.swift` or `{Service}Fake.swift`
- **Factories:** `{Service}Factory.swift`
- **Extensions:** `{Type}+{Purpose}.swift` (e.g., `String+Validation.swift`)

#### Resource Files
- **Assets:** Use `.xcassets` bundles in package `Resources/` directory
- **Strings:** `Localizable.strings`
- **Configuration:** `.plist` files

**SwiftPM Resource Declaration:**
```swift
// Package.swift
target(
  name: "DesignSystem",
  resources: [.process("Resources")]
)
```
- Asset catalogs live under `Sources/PackageName/Resources/*.xcassets`
- No global asset lookups—each package owns its bundle via `Bundle.module`

### Module Dependency Rules

#### Allowed Dependencies
- **Features** → Kits, Shared (AppFoundation, TestSupport)
- **Kits** → Other Kits, Shared (AppFoundation, TestSupport)
- **Shared** → Minimal external dependencies only
- **ThirdParty** → Self-contained, no internal dependencies

#### Dependency Hierarchy
```
Features (top level)
    ↓
Kits (middle level)
    ↓
Shared (foundation level)
    ↓
ThirdParty (isolated)
```

**Never create circular dependencies:** If Kit A needs Kit B, then Kit B cannot depend on Kit A.

#### Critical Dependency Rules

**❌ FORBIDDEN: Feature-to-Feature Dependencies**
- Features must NEVER depend on other Features directly
- Use AppFoundation service protocols instead
- Example: HomeForYou should NOT import PostDetail directly

**✅ CORRECT: Protocol-Based Communication**
```swift
// ❌ WRONG: Feature importing another Feature
import PostDetail
CommentSheet(post: post)

// ✅ CORRECT: Using AppFoundation service protocol
@Environment(\.deps) private var deps
deps.commentComposition?.createCommentSheet(for: post, ...)
```

**❌ FORBIDDEN: DesignSystem Business Logic Dependencies**
- DesignSystem should only depend on AppFoundation
- NO direct dependencies on Engagement, Networking, or other Kits
- Business logic protocols defined in AppFoundation, implemented in respective Kits

**✅ CORRECT: Kit Protocol Dependencies**
```swift
// ❌ WRONG: DesignSystem importing Engagement
import Engagement
EngagementService.toggleLike(...)

// ✅ CORRECT: DesignSystem using AppFoundation protocol
import AppFoundation
deps.engagement?.toggleLike(...)
```

### DesignSystem Contract (Value-Only, Enforced)

**Allowed imports:**
- SwiftUI, Foundation, CoreGraphics
- Conditionally: `UIKit` under `#if os(iOS)` for haptics/rendering only
- AppFoundation **value types** (themes, tokens, lightweight `User.ID`, `Post.ID` types)

**MUST NOT:**
- Access `Dependencies`, service protocols, or any runtime services
- Import service kits (Engagement, Networking, SupabaseKit, Persistence)
- Use `@Environment(\.deps)` or any dependency injection mechanism

**Enforce:** `DesignSystem` exports only `struct`, `enum`, `View`, `ShapeStyle`, and `PreviewProvider`—no `actor`, `class` services.

**Lint enforcement:**
- `designsystem-service-access`: Fail if `import Dependencies` or `@Environment(\.deps)` appears in DesignSystem
- Value-only types: Warn if DesignSystem defines `class` or `actor` types (prefer `struct`, `enum`)

### Cross-Feature UI Reuse Rule

**Decision test:**
- If the component is **purely presentational** (no navigation, no data fetch, no feature coupling), place in **DesignSystem**.
- If it needs **profile/search/messaging hooks**, or depends on domain models/services, create a **focused Kit** (e.g., `PeopleKit`) that exposes:
  - `UserRowView` (UI)
  - `PeopleService` protocols (optional)
  - Domain mappers/adapters

### Recommender Kit Contract

**Scope:** Client wrapper for server-driven ranking.

**Allowed:**
- Signal collection (views, engagements, timestamps)
- Lightweight local filtering (e.g., hide muted users)
- Network calls to recommendation endpoints

**Forbidden:**
- Ranking heuristics or algorithms
- Scoring models (server-side only)
- Client-side optimization logic

> All ranking/scoring logic stays on the server. Client only fetches recommendations.

### Why Authentication Lives in AppFoundation (and Lifecycle Exceptions)

**Authentication** (session bootstrap, SIWA, keychain) is implemented in **Shared/AppFoundation** because it:
1) is required before UI composition,
2) is consumed across nearly all modules, and
3) would create dependency cycles if implemented elsewhere.

**Lifecycle Exceptions (future, review required):**
- Feature Flags
- Remote Config

**Admission checklist (ALL must be true):**
- ≥80% of modules depend on it
- Early bootstrap before first view
- Protocol-first surface in `ServiceProtocols.swift`
- Mocks in `Shared/TestSupport`
- Kit implementation would create cycles

> Everything else: protocols in AppFoundation, implementations in Kits.

**Naming Rule:**
- Use `Authentication` (NOT `Auth`) to avoid collision with Supabase Swift `Auth` target.
- Always import as `import Authentication` when using authentication components.

**Auth Architecture:**
- **Feature:** `Features/Authentication/` - UI/UX and app-level state management
- **Services:** `Shared/AppFoundation/` - Service protocols, implementations, session management

### Models & Mapping Policy

**Location hierarchy:**
- Domain models → `Shared/AppFoundation/Domain` (User, Post, Comment, IDs, enums)
- Generated API types → `Kits/Networking/Generated` (OpenAPI/Supabase responses)
- Mappers → `Kits/Networking/Mappers` (Generated → Domain)

**Rule:** Features/Kits consume **domain** models only. Never import `Networking.Generated` outside the Networking Kit.

**Lint enforcement:**
- `models-usage`: Fail if non-Networking targets import `Networking.Generated`

### Routing Rules (AppFoundation)

**File location:** `Shared/AppFoundation/Routes.swift`

**Structure:**
- One `enum` per tab: `FeedRoute`, `DMRoute`, `ProfileRoute`, `SearchRoute`, `ComposeRoute`
- **Payloads:** Must be stable identifiers or small value types (e.g., `Post.ID`, `User.ID`), no `View` or closures
- Provide convenience factories for deep links

**Lint enforcement:**
- `route-file-location`: Fail if any `enum .*Route` defined outside `Shared/AppFoundation/Routes.swift`
- Route payload check: Fail if any route payload type contains `some View` or `View`

### Why Navigation is in AppFoundation (Not a Kit)

Navigation infrastructure lives in `Shared/AppFoundation` because:

1. **Ubiquitous Dependency:** Every feature tab needs route definitions
2. **Deep Link Coordination:** Centralized deep link → route parsing
3. **Tab Coordination:** Selection state and cross-tab navigation logic
4. **Type Safety:** Shared route types ensure consistent navigation patterns
5. **Composition Root Proximity:** Navigation wiring happens at app root level

**Navigation Files (in AppFoundation):**
- `Routes.swift` - App-wide route enum definitions (one enum per tab flow)
- `DeepLinkRouter.swift` - URL parsing and route construction
- `NavigationEnvironment.swift` - SwiftUI environment for navigation coordination

### Tools Directory

Development tools and automation:

```
Tools/
└── agctl/                     # Agora CLI tool (Swift-based)
    ├── Package.swift          # Tool package manifest
    ├── Sources/               # CLI implementation
    ├── install.sh             # Installation script
    ├── README.md              # Tool documentation
    └── QUICKSTART.md          # Quick reference
```

**agctl** is the primary tool for:
- Building individual modules: `agctl build {ModuleName}`
- Testing modules: `agctl test {ModuleName}`
- Generating OpenAPI client: `agctl generate openapi`
- Validating project structure: `agctl validate modules`
- Installing git hooks: `agctl install-hooks`

See `Tools/agctl/README.md` or `docs/AGCTL_GUIDE.md` for complete documentation.

### Resources Directory

Main app resources and entry point (not packages):

```
Resources/
├── AgoraApp.swift              # Main app entry point (@main)
├── ContentView.swift           # Root SwiftUI view
├── RootView.swift              # Root TabView container
├── LoadingView.swift           # App loading state view
├── Assets.xcassets/            # App-level assets (icons, colors)
├── Info.plist                  # App configuration
├── Agora.entitlements          # App entitlements (Sign in with Apple)
├── Localizable.strings         # App-level localized strings
└── Configs/                    # Environment plists (see configuration.mdc)
```

### Quick Reference: Common Tasks

| Task | Location | Command |
|------|----------|---------|
| New user-facing feature | `Packages/Features/{FeatureName}/` | `agctl build {FeatureName}` |
| New reusable UI component | `Packages/Kits/DesignSystem/` | `agctl build DesignSystem` |
| New API endpoint | `OpenAPI/agora.yaml` | `agctl generate openapi` |
| New service/client | `Packages/Kits/{ServiceName}/` | `agctl build {ServiceName}` |
| Service protocol | `Packages/Shared/AppFoundation/ServiceProtocols.swift` | `agctl build AppFoundation` |
| Supabase wrapper | `Packages/Kits/SupabaseKit/` | `agctl build SupabaseKit` |
| Auth-related service | `Packages/Shared/AppFoundation/` | `agctl build AppFoundation` |
| App-wide utility | `Packages/Shared/AppFoundation/` | `agctl build AppFoundation` |
| Test helper | `Packages/Shared/TestSupport/` | `agctl test TestSupport` |
| Navigation route | `Packages/Shared/AppFoundation/Routes.swift` | - |
| Environment config | `Resources/Configs/{Environment}.plist` | - |
| Build automation tool | `Tools/agctl/` | `agctl --help` |
| Database migration | `database/migrations/{number}_{name}.sql` | - |

### Test Structure

**Lanes (carve now to prevent drift):**
- **Per-package unit tests:** `Packages/*/Tests/*` (package:Tests target)
- **Cross-module snapshot/UI tests:** `Tests/` (top-level)
- **Legacy app-target tests:** `AgoraTests/`, `AgoraUITests/` (goal: migrate or keep minimal)

**Framework:**
- Default: Swift Testing
- XCTest only for UI tests

**Naming:**
- `{Type}Tests.swift` (unit tests)
- `{Type}SnapshotTests.swift` (visual regression)

**Snapshots:**
- Prefer per-package snapshots
- Cross-feature snapshots at top-level `Tests/`

### Forbidden Imports (Regex Enforced)

**Allowed imports:**
- Feature → {Kit, Shared}
- Kit → {Kit, Shared}
- Shared → {external deps only}
- ThirdParty → {}

**Forbidden (lints enabled):**
- `forbidden-imports`: Features importing Features
  - Regex: `^import\s+(Features\/.+)$` → fail
- `designsystem-service-access`: DesignSystem importing services
  - Regex: `^@Environment\(\.deps\)` or `^import\s+(Engagement|Networking|SupabaseKit|Persistence)$` → fail
- `feature-to-feature-dep`: Feature-to-Feature dependencies
  - Regex: `^import\s+(Features\/.+)$` → fail (enforce protocol-based communication)
- `models-usage`: Non-Networking importing Generated
  - Regex: `^import\s+Networking.*Generated$` → fail (use domain models)
- `route-file-location`: Route enums outside Routes.swift
  - Regex: `enum .*Route` outside `Shared/AppFoundation/Routes.swift` → fail

**Additional validation checks:**
- Bundle.resource presence for packages that ship UI
- Target graph check: no cycles; Features depend only on Kits/Shared; Kits never depend on Features
- Name checkers: {Service,Client}{Live,Mock}, {Type}+{Purpose}.swift extensions
- Naming collisions: Warn if new target name collides with {Auth, Core, Foundation, UIKit, SwiftUI, Networking, Storage}
- Platform guards: Warn if UIKit imported without `#if os(iOS)` in non-iOS-only packages
- No global singletons—all service access via @Environment(\.deps) or DI initializer
- Service protocols defined in AppFoundation (`ServiceProtocols.swift`) with explicit path reference

### Platform & UIKit Usage (iOS-only)

**Guards:**
- The app targets **iOS only**. Do **not** introduce Catalyst/tvOS/watchOS targets.
- All UIKit usage must be guarded with `#if os(iOS)` or `#if canImport(UIKit)`
- Non-iOS fallback in DesignSystem must be value-only (no services); prefer CoreGraphics

**UIKit Isolation Rule:**
- Any UIKit usage must live in `Packages/Kits/UIKitBridge/` and be exposed as SwiftUI-native bridges.
- DesignSystem may call UIKit only behind `#if os(iOS)` and **never** expose UIKit types in public APIs.
- SwiftUI is the primary framework; UIKit bridges are only for system-required UIs, rich editing, or specialized input.
- Never import UIKit outside of UIKitBridge package.

**Lint enforcement:**
- `platform-guards`: Warn if UIKit imported without `#if os(iOS)` in non-iOS-only packages
- `uikit-isolation`: Fail if `import UIKit` appears outside `Packages/Kits/UIKitBridge/`

### Related Rules

For detailed information on specific topics:
- **Naming Conventions:** `naming.mdc` - Comprehensive naming guidelines for types, variables, functions, and component types
- **Module standards:** `module-standards.mdc` - How to create quality packages
- **Configuration:** `configuration.mdc` - Build configs, environments, OpenAPI
- **Navigation:** `navigation.mdc` - Navigation patterns and deep links
- **Dependency Injection:** `dependency-injection.mdc` - DI patterns and scopes
- **Concurrency:** `swift-concurrency.mdc` - Async/await and actors
