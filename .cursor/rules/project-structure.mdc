---
description: When needing to know where to place a new file, organize code into the correct package, understand the Packages/ directory structure, or determine which module (Feature/Kit/Shared/ThirdParty) should contain new functionality.
alwaysApply: false
---
## Agora iOS Project Structure

### Overview

This rule defines where files and code belong in the Agora iOS app's Swift Package Manager (SPM) modular architecture. Use this when creating new files, features, or modules to ensure correct placement.

### Root Directory Structure

```
Agora/
├── Agora.xcodeproj/           # Main Xcode project
├── AgoraTests/                # Main app unit tests
├── AgoraUITests/              # Main app UI tests
├── database/                  # Supabase migrations and schema
├── docs/                      # Project documentation
├── OpenAPI/                   # API specifications (see ios-configuration.mdc)
├── Packages/                  # Swift Package modules (see below)
├── Resources/                 # App resources and main app files
├── Scripts/                   # Legacy CI/test scripts (most replaced by agctl)
├── supabase/                  # Supabase Edge Functions
├── Tests/                     # Cross-module snapshot/UI tests
├── Tools/                     # Development tools (agctl CLI)
└── Package.swift              # Root package manifest
```

### Packages Directory Structure

The `Packages/` directory is organized into **four main categories**:

#### Features (`Packages/Features/`)
**When to use:** Creating user-facing features that represent distinct app functionality

```
Features/
├── Auth/                      # Auth UI/UX + app-level state (services are in AppFoundation)
├── Compose/                   # Post composition and media upload
├── DirectMessages/            # Direct messaging (DMs)
├── HomeFollowing/             # Following feed (chronological)
├── HomeForYou/                # For You feed (recommendations)
├── Notifications/             # Push notifications and in-app alerts
├── PostDetail/                # Individual post viewing
├── Profile/                   # User profiles and settings
├── Search/                    # People and content search
└── Threading/                 # Reply threads and conversations
```

**Feature modules contain:**
- SwiftUI views and view models
- Feature-specific business logic
- Feature-level coordinators and state management
- Dependencies on Kits and Shared modules

**Important:** Feed switching (For You ↔ Following) lives in `Resources/RootView.swift` at the app root level, not in a separate feature package. This is app-level orchestration, not feature-specific business logic. Features should be isolated and independent; avoid creating "coordinator" features that just combine other features.

**Composition Rules:**
- Composition lives at app root (`Resources/RootView.swift` and Root composition) or in AppFoundation Navigation
- Features remain leaf packages
- Features never push other Features directly. They emit intents/route requests (via AppFoundation types). App root (or Nav env) performs the cross-tab navigation.

#### Kits (`Packages/Kits/`)
**When to use:** Creating reusable functionality that provides specific capabilities

```
Kits/
├── Analytics/                 # PostHog analytics wrapper
├── DesignSystem/              # UI components, colors, typography
├── Engagement/                # Post engagement (likes, reposts, shares)
├── Media/                     # Image/video capture, processing, upload
├── Moderation/                # Content moderation and reporting
├── Networking/                # API client and network layer (OpenAPI)
├── Persistence/               # SwiftData models and caching
├── Recommender/               # Recommendation engine client
├── SupabaseKit/               # Supabase services wrapper (auth, realtime, storage)
└── Verification/              # Device attestation and anti-bot
```

**Kit modules contain:**
- Service protocols and implementations
- Reusable business logic
- Third-party SDK wrappers
- Dependencies on other Kits and Shared modules

**Key Kit Guidelines:**
- **SupabaseKit**: PostgREST/Realtime/Auth/Storage/Edge Functions for Supabase. Never host OpenAPI clients here.
- **Networking**: OpenAPI client and non-Supabase HTTP/WS. Never import Supabase from here.
- **DesignSystem**: UI components only - NO business logic dependencies
  - **MUST NOT import:** SwiftData, SupabaseKit, or any business-logic Kit
  - **Allowed imports:** SwiftUI, Combine (view concerns), AppFoundation (types/themes), TestSupport (tests only)
- **Engagement**: Business logic for post interactions - protocols defined in AppFoundation (`ServiceProtocols.swift`)

**Important:** Authentication services (Sign in with Apple, phone verification, session management) live in `AppFoundation`, not as a Kit. See "Why Auth is in AppFoundation" below.

#### Shared (`Packages/Shared/`)
**When to use:** Creating cross-cutting concerns and utilities used everywhere

```
Shared/
├── AppFoundation/             # Core app utilities and services
└── TestSupport/               # Testing utilities and mocks
```

**AppFoundation contains:**
- Environment detection and configuration (`Environment.swift`, `AppConfig.swift`)
- Dependency injection (`Dependencies.swift`, `Dependencies+Environment.swift`)
- Navigation infrastructure (`Routes.swift`, `DeepLinkRouter.swift`, `NavigationEnvironment.swift`)
- Appearance preferences (`AppearancePreference.swift`)
- **Service protocols** (`ServiceProtocols.swift`) - All service interfaces defined here
- Auth services (`SupabaseAuthService.swift`, `SessionStore.swift`, `KeychainHelper.swift`)
- Phone verification (`TwilioPhoneVerifier.swift`)
- Mock implementations (`MockServices.swift`)
- Service factories (`ServiceFactory.swift`)

**Critical:** AppFoundation defines service protocols, but implementations live in their respective Kits. This prevents circular dependencies and enables clean testing.

**Exception:** Auth implementations live in Shared/AppFoundation due to lifecycle coupling (bootstrap, session, environment). Any future candidate for AppFoundation implementation must be formally reviewed; the default is: implementations live in Kits.

#### ThirdParty (`Packages/ThirdParty/`)
**When to use:** Integrating third-party SDKs that need custom Swift Package wrappers

```
ThirdParty/
├── hCaptcha/                  # hCaptcha challenge SDK
├── OneSignal/                 # Push notification service
├── PostHog/                   # Analytics SDK
└── Sentry/                    # Crash reporting SDK
```

**Use ThirdParty when:**
- SDK doesn't support SPM natively
- Need to wrap SDK in protocol interface
- Custom integration logic required

### Decision Tree: Where Does X Go?

#### "I'm creating a new view/screen"
→ **Feature module** in `Packages/Features/`
- If it's part of an existing feature, add to that feature's package
- If it's a new major feature, create a new Feature package

#### "I'm creating a reusable UI component"
→ **DesignSystem Kit** in `Packages/Kits/DesignSystem/`
- Buttons, cards, text styles, colors, etc.

#### "I'm creating a service/client"
→ **Kit module** in `Packages/Kits/`
- If it's auth-related → **AppFoundation** (`Shared/AppFoundation`)
- If it's a new capability → Create new Kit or add to existing Kit

#### "I'm creating app-wide utilities"
→ **AppFoundation** in `Packages/Shared/AppFoundation/`
- Extensions, helpers, configuration, DI infrastructure

#### "I'm creating test utilities"
→ **TestSupport** in `Packages/Shared/TestSupport/`
- Mock implementations, test fixtures, shared test helpers

#### "I'm creating navigation routes"
→ **AppFoundation** in `Packages/Shared/AppFoundation/Routes.swift`
- Tab-level routes (FeedRoute, SearchRoute, etc.)
- Deep link parsing logic

#### "I'm integrating a third-party SDK"
- If available via SPM → Add to Package.swift dependencies
- If needs custom wrapper → **ThirdParty** in `Packages/ThirdParty/`

**Only create ThirdParty wrapper if:**
- The SDK lacks SPM or needs binary vendoring
- You need protocol abstraction to avoid leaking types
- You must gate platform/features or inject config at init
- If none apply, depend on the vendor package directly in the using Kit

#### "I'm creating a service that other modules need"
- Define protocol in **AppFoundation** (`ServiceProtocols.swift`)
- Implement in appropriate **Kit** module
- Register in **Dependencies** container
- Example: `CommentCompositionProtocol` in AppFoundation, `CommentCompositionService` in PostDetail

#### "I'm adding bookmarking/collections"
→ **Kit** (domain logic) + small **Feature** for UI, protocols in AppFoundation

#### "I'm adding local caching or persistence"
→ **Persistence Kit**; define models here, expose read/write interfaces; do not put SwiftData code in Features.

#### "I'm creating a Supabase wrapper"
- Create new **SupabaseKit** module
- Define protocols for Supabase services
- Implement live and mock versions
- Other modules can depend on SupabaseKit directly

### Package Structure Template

Every Swift Package must follow this structure:

```
PackageName/
├── Package.swift              # Package manifest (see ios-module-standards.mdc)
├── README.md                  # Package documentation
├── Sources/
│   └── PackageName/           # Source code (matches package name exactly)
│       ├── PackageName.swift  # Main public interface
│       └── [other files]      # Implementation files
└── Tests/
    └── PackageNameTests/      # Test files
        └── PackageNameTests.swift
```

**Critical naming rule:** The `Sources/PackageName/` directory name must **exactly match** the package name in `Package.swift`.

### File Naming Conventions

#### Swift Files
- **Views:** `{Feature}View.swift` (e.g., `ComposeView.swift`)
- **ViewModels:** `{Feature}ViewModel.swift` (e.g., `ComposeViewModel.swift`)
- **Models:** `{Feature}.swift` or `{Feature}Model.swift`
- **Business Logic Services:** `{Service}Service.swift` / `{Service}ServiceLive.swift` / `{Service}ServiceMock.swift`
- **Network Clients:** `{Client}Client.swift` / `{Client}ClientLive.swift` / `{Client}ClientMock.swift`
- **Test Mocks:** `{Service}Mock.swift` or `{Service}Fake.swift`
- **Factories:** `{Service}Factory.swift`
- **Extensions:** `{Type}+{Purpose}.swift` (e.g., `String+Validation.swift`)

#### Resource Files
- **Assets:** Use `.xcassets` bundles in package `Resources/` directory
- **Strings:** `Localizable.strings`
- **Configuration:** `.plist` files

**SwiftPM Resource Declaration:**
```swift
// Package.swift
target(
  name: "DesignSystem",
  resources: [.process("Resources")]
)
```
- Asset catalogs live under `Sources/PackageName/Resources/*.xcassets`
- No global asset lookups—each package owns its bundle via `Bundle.module`

### Module Dependency Rules

#### Allowed Dependencies
- **Features** → Kits, Shared (AppFoundation, TestSupport)
- **Kits** → Other Kits, Shared (AppFoundation, TestSupport)
- **Shared** → Minimal external dependencies only
- **ThirdParty** → Self-contained, no internal dependencies

#### Dependency Hierarchy
```
Features (top level)
    ↓
Kits (middle level)
    ↓
Shared (foundation level)
    ↓
ThirdParty (isolated)
```

**Never create circular dependencies:** If Kit A needs Kit B, then Kit B cannot depend on Kit A.

#### Critical Dependency Rules

**❌ FORBIDDEN: Feature-to-Feature Dependencies**
- Features must NEVER depend on other Features directly
- Use AppFoundation service protocols instead
- Example: HomeForYou should NOT import PostDetail directly

**✅ CORRECT: Protocol-Based Communication**
```swift
// ❌ WRONG: Feature importing another Feature
import PostDetail
CommentSheet(post: post)

// ✅ CORRECT: Using AppFoundation service protocol
@Environment(\.deps) private var deps
deps.commentComposition?.createCommentSheet(for: post, ...)
```

**❌ FORBIDDEN: DesignSystem Business Logic Dependencies**
- DesignSystem should only depend on AppFoundation
- NO direct dependencies on Engagement, Networking, or other Kits
- Business logic protocols defined in AppFoundation, implemented in respective Kits

**✅ CORRECT: Kit Protocol Dependencies**
```swift
// ❌ WRONG: DesignSystem importing Engagement
import Engagement
EngagementService.toggleLike(...)

// ✅ CORRECT: DesignSystem using AppFoundation protocol
import AppFoundation
deps.engagement?.toggleLike(...)
```

### Why Auth is in AppFoundation (Not a Kit)

Authentication services live in `Shared/AppFoundation` rather than a separate `AuthKit` because:

1. **Foundation-Level Concern:** Auth is used by nearly every feature and kit
2. **Tight Integration:** Auth services integrate deeply with environment config and app lifecycle
3. **Avoid Circular Dependencies:** Many kits need auth services; having AuthKit would create dependency issues
4. **Protocol First:** Service protocols belong in Shared/AppFoundation. Implementations live in Kits.
   **Exception:** Auth implementations live in Shared/AppFoundation due to lifecycle coupling (bootstrap, session, environment).
5. **Simplicity:** One place for all auth code is clearer than splitting UI (Feature) and Services (Kit)

**Auth Architecture:**
- **Feature:** `Features/Authentication/` - UI/UX and app-level state management (exports as `Authentication` to avoid Supabase conflict)
- **Services:** `Shared/AppFoundation/` - Service protocols, implementations, session management

**Important:** The Authentication feature package exports its product as `Authentication` (not `Auth`) to avoid naming conflicts with the Supabase Swift package, which also exports an `Auth` target. Always import as `import Authentication` when using the authentication UI components.

**Import Style Example:**
```swift
import Authentication
// Use Authentication components
```

### Why Navigation is in AppFoundation (Not a Kit)

Navigation infrastructure lives in `Shared/AppFoundation` because:

1. **Ubiquitous Dependency:** Every feature tab needs route definitions
2. **Deep Link Coordination:** Centralized deep link → route parsing
3. **Tab Coordination:** Selection state and cross-tab navigation logic
4. **Type Safety:** Shared route types ensure consistent navigation patterns
5. **Composition Root Proximity:** Navigation wiring happens at app root level

**Navigation Files (in AppFoundation):**
- `Routes.swift` - App-wide route enum definitions (one enum per tab flow)
- `DeepLinkRouter.swift` - URL parsing and route construction
- `NavigationEnvironment.swift` - SwiftUI environment for navigation coordination

### Tools Directory

Development tools and automation:

```
Tools/
└── agctl/                     # Agora CLI tool (Swift-based)
    ├── Package.swift          # Tool package manifest
    ├── Sources/               # CLI implementation
    ├── install.sh             # Installation script
    ├── README.md              # Tool documentation
    └── QUICKSTART.md          # Quick reference
```

**agctl** is the primary tool for:
- Building individual modules: `agctl build {ModuleName}`
- Testing modules: `agctl test {ModuleName}`
- Generating OpenAPI client: `agctl generate openapi`
- Validating project structure: `agctl validate modules`
- Installing git hooks: `agctl install-hooks`

See `Tools/agctl/README.md` or `docs/AGCTL_GUIDE.md` for complete documentation.

### Resources Directory

Main app resources and entry point (not packages):

```
Resources/
├── AgoraApp.swift              # Main app entry point (@main)
├── ContentView.swift           # Root SwiftUI view
├── RootView.swift              # Root TabView container
├── LoadingView.swift           # App loading state view
├── Assets.xcassets/            # App-level assets (icons, colors)
├── Info.plist                  # App configuration
├── Agora.entitlements          # App entitlements (Sign in with Apple)
├── Localizable.strings         # App-level localized strings
└── Configs/                    # Environment plists (see ios-configuration.mdc)
```

### Quick Reference: Common Tasks

| Task | Location | Command |
|------|----------|---------|
| New user-facing feature | `Packages/Features/{FeatureName}/` | `agctl build {FeatureName}` |
| New reusable UI component | `Packages/Kits/DesignSystem/` | `agctl build DesignSystem` |
| New API endpoint | `OpenAPI/agora.yaml` | `agctl generate openapi` |
| New service/client | `Packages/Kits/{ServiceName}/` | `agctl build {ServiceName}` |
| Service protocol | `Packages/Shared/AppFoundation/ServiceProtocols.swift` | `agctl build AppFoundation` |
| Supabase wrapper | `Packages/Kits/SupabaseKit/` | `agctl build SupabaseKit` |
| Auth-related service | `Packages/Shared/AppFoundation/` | `agctl build AppFoundation` |
| App-wide utility | `Packages/Shared/AppFoundation/` | `agctl build AppFoundation` |
| Test helper | `Packages/Shared/TestSupport/` | `agctl test TestSupport` |
| Navigation route | `Packages/Shared/AppFoundation/Routes.swift` | - |
| Environment config | `Resources/Configs/{Environment}.plist` | - |
| Build automation tool | `Tools/agctl/` | `agctl --help` |
| Database migration | `database/migrations/{number}_{name}.sql` | - |

### Test Placement Strategy

**Test Routing Table:**
- **Per-package unit tests:** `Packages/*/Tests/` (live inside each package)
- **Cross-module snapshot/UI tests:** `Tests/` (top-level)
- **Legacy app-target tests:** `AgoraTests/`, `AgoraUITests/` (goal: migrate or keep minimal)
- **New tests default:** Swift Testing; XCTest only where UI testing requires
- **Snapshot baselines:** Live inside each Feature/Kit test target, but cross-feature snapshots belong in top-level `Tests/`

### Enforceability: Machine-Checkable Rules

**Forbidden Imports Matrix:**
```
# Allowed imports
Feature → {Kit, Shared}
Kit     → {Kit, Shared}
Shared  → {}
ThirdParty → {}

# Forbidden
Feature → Feature
DesignSystem → {Engagement, Networking, SupabaseKit, Persistence}
Kit → Feature
```

**Validation Checks (agctl validate modules):**
- Bundle.resource presence for packages that ship UI
- Target graph check: no cycles; Features depend only on Kits/Shared; Kits never depend on Features
- Name checkers: {Service,Client}{Live,Mock}, {Type}+{Purpose}.swift extensions
- Routes location check: Routes.swift only under Shared/AppFoundation
- Auth exception: allow AppFoundation to contain Auth*Live.swift; block other *ServiceLive.swift there
- No global singletons—all service access via @Environment(\.deps) or DI initializer
- Service protocols defined in AppFoundation (`ServiceProtocols.swift`) with explicit path reference

### Related Rules

For detailed information on specific topics:
- **Naming Conventions:** `ios-naming.mdc` - Comprehensive naming guidelines for types, variables, functions, and component types
- **Module standards:** `ios-module-standards.mdc` - How to create quality packages
- **Configuration:** `ios-configuration.mdc` - Build configs, environments, OpenAPI
- **Navigation:** `ios-navigation.mdc` - Navigation patterns and deep links
- **Dependency Injection:** `ios-di-injection.mdc` - DI patterns and scopes
- **Concurrency:** `swift-concurrency.mdc` - Async/await and actors
