---
description: When setting up build configurations, managing Xcode schemes (Debug/Staging/Production), configuring environment-specific settings, working with OpenAPI code generation, managing xcconfig files, setting up API endpoints, or handling app secrets and configuration plists.
alwaysApply: false
---
## Agora iOS Build Configuration

### Overview

This rule covers all aspects of configuring and building the Agora iOS app across different environments (Staging and Production), including Xcode schemes, xcconfig files, environment plists, OpenAPI integration, and resource management.

### Xcode Schemes

The project includes two environment-specific schemes:

#### Agora Staging
- **Purpose:** Pre-production testing with real or mock services
- **Bundle ID:** `Ergo-Sum.Agora.stg`
- **Display Name:** "Agora Staging"
- **Build Configuration:** Debug-Staging (debug) or Release-Staging (TestFlight)
- **Compilation Conditions:** `DEBUG`, `STAGING` (debug) or `STAGING` (release)
- **Use Cases:**
  - Local development with mock services
  - QA testing with real backend
  - Beta testing via TestFlight
  - Integration testing

#### Agora Production
- **Purpose:** App Store releases
- **Bundle ID:** `Ergo-Sum.Agora`
- **Display Name:** "Agora"
- **Build Configuration:** Release-Production
- **Compilation Conditions:** None (production is default)
- **Use Cases:**
  - App Store distribution
  - Production builds

**Scheme Selection:** Always verify you've selected the correct scheme in Xcode before building or running.

### xcconfig File Hierarchy

The project uses hierarchical xcconfig files for environment-specific builds:

```
Resources/Configs/
├── Base.xcconfig                 # Shared settings across all environments
├── Debug.xcconfig                # Base debug settings (extends Base)
├── Release.xcconfig              # Base release settings (extends Base)
├── Debug-Staging.xcconfig        # Staging environment debug builds
├── Release-Staging.xcconfig      # Staging environment release builds
└── Release-Production.xcconfig   # Production release builds
```

#### Configuration Hierarchy

```
Base.xcconfig (Swift version, deployment target, etc.)
    ↓
Debug.xcconfig / Release.xcconfig (build-type settings)
    ↓
Debug-Staging / Release-Staging / Release-Production (environment-specific)
```

#### Key Settings in Environment Configs

**Must be defined in each environment-specific xcconfig:**

```xcconfig
// Debug-Staging.xcconfig
PRODUCT_BUNDLE_IDENTIFIER = Ergo-Sum.Agora.stg
INFOPLIST_KEY_CFBundleDisplayName = Agora Staging
SWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited) DEBUG STAGING
AGORA_ENV = staging

// Release-Production.xcconfig
PRODUCT_BUNDLE_IDENTIFIER = Ergo-Sum.Agora
INFOPLIST_KEY_CFBundleDisplayName = Agora
SWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited)
AGORA_ENV = production
```

### Environment Configuration Files

Environment-specific secrets and configuration are stored in separate plist files:

```
Resources/Configs/
├── Staging.plist              # Staging client secrets (gitignored)
├── Production.plist           # Production client secrets (gitignored)
├── Staging.plist.example      # Staging template with fake values
├── Production.plist.example   # Production template with fake values
├── .secrets                   # Operational secrets (gitignored)
└── README.md                  # Setup instructions
```

#### Client Secrets vs Operational Secrets

**Client Secrets (in `.plist` files):**
- Used by the iOS app at runtime
- Loaded via `AppConfig.swift`
- Safe to include in client applications (protected by service-level security)
- **Examples:** anon keys, public API endpoints, SDK keys
- **Committed:** Never (use `.plist.example` templates instead)

**Operational Secrets (in `.secrets` file):**
- Used by developers for server-side operations only
- **NEVER** included in the iOS app bundle
- For database administration, migrations, CI/CD pipelines
- **Examples:** service role keys, database passwords, admin tokens
- **Format:** Plain text documentation file for developer reference
- **Committed:** Never (gitignored)

#### Required Keys in Environment Plists

All environment plist files must include these keys:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- Backend Configuration -->
    <key>apiBaseURL</key>
    <string>https://api.example.com</string>
    
    <key>webShareBaseURL</key>
    <string>https://share.example.com</string>
    
    <!-- Supabase Configuration -->
    <key>supabaseURL</key>
    <string>https://xxxxx.supabase.co</string>
    
    <key>supabaseAnonKey</key>
    <string>eyJhbGci...</string>
    
    <!-- Third-Party Services -->
    <key>posthogKey</key>
    <string>phc_xxxxx</string>
    
    <key>sentryDSN</key>
    <string>https://xxxxx@sentry.io/xxxxx</string>
    
    <key>twilioVerifyServiceSid</key>
    <string>VAxxxxx</string>
    
    <key>oneSignalAppId</key>
    <string>xxxxx-xxxxx-xxxxx</string>
    
    <!-- Development Settings -->
    <key>mockExternalServices</key>
    <true/> <!-- or <false/> for production -->
</dict>
</plist>
```

#### Loading Configuration in Code

Configuration is loaded via `AppConfig.swift` in AppFoundation:

```swift
// In Packages/Shared/AppFoundation/Sources/AppFoundation/AppConfig.swift
public struct AppConfig: Sendable {
    public let apiBaseURL: URL
    public let supabaseURL: URL
    public let supabaseAnonKey: String
    public let posthogKey: String
    public let mockExternalServices: Bool
    // ... other properties
    
    public static func load() -> AppConfig {
        #if STAGING
        let plistName = "Staging"
        #else
        let plistName = "Production"
        #endif
        
        guard let path = Bundle.main.path(forResource: plistName, ofType: "plist"),
              let dict = NSDictionary(contentsOfFile: path) else {
            fatalError("Could not load \(plistName).plist")
        }
        
        // Parse and return configuration
    }
}
```

### OpenAPI Integration

**Purpose:** Type-safe API client generation from OpenAPI specifications

#### Directory Structure

```
OpenAPI/
├── agora.yaml              # OpenAPI 3.0 spec (source of truth for API)
├── openapi-config.yaml     # Generator configuration
├── VERSION.lock            # Generator version (auto-created, committed)
└── README.md               # OpenAPI documentation and workflow
```

#### Generated Code Location

```
Packages/Kits/Networking/Sources/Networking/Generated/
└── *.swift                 # Generated types, client, and operations (committed)
```

#### Pre-Generation Approach

**Key Concept:** Code is generated **before** compilation (not during build)

**Workflow:**

1. Edit OpenAPI spec:
   ```bash
   vim OpenAPI/agora.yaml
   ```

2. Generate Swift client code:
   ```bash
   agctl generate openapi
   ```

3. Review and commit changes:
   ```bash
   git diff Packages/Kits/Networking/Sources/Networking/Generated/
   git add OpenAPI/ Packages/Kits/Networking/Sources/Networking/Generated/
   git commit -m "Update API endpoints"
   ```

**Why commit generated code:**
- Fast builds (no generation during compilation)
- Predictable code and diffs
- Version control visibility
- CI/CD can verify sync between spec and generated code

#### Generator Installation

**Option 1 - Mint (Recommended):**
```bash
mint install apple/swift-openapi-generator
```

**Option 2 - Homebrew:**
```bash
brew install swift-openapi-generator
```

**Option 3 - agctl (handles installation detection):**
```bash
# agctl automatically tries multiple methods: Mint → Homebrew → SPM → Docker
agctl generate openapi
```

#### Generator Configuration

**File:** `OpenAPI/openapi-config.yaml`

```yaml
generation:
  accessModifier: public              # Public for use in features
  addSendableConformance: true        # Swift 6.2 concurrency
  asyncClient: true                   # Async/await support
  concurrency:
    useActors: true                   # Actor-based thread safety

output:
  paths:
    sources: "../Packages/Kits/Networking/Sources/Networking/Generated"

options:
  stableFileNames: true               # Consistent naming for git
  datesAsISO8601: true                # ISO 8601 date format
```

#### Networking Kit Integration

The Networking Kit wraps generated code with app-specific abstractions:

```swift
// In Packages/Kits/Networking/

// High-level protocol
public protocol AgoraAPIClient {
    func fetchPosts() async throws -> [Post]
    func createPost(_ post: NewPost) async throws -> Post
}

// Production implementation using generated code
public final class OpenAPIAgoraClient: AgoraAPIClient {
    // Uses generated Client and Operations
}

// Mock implementation for staging
public final class StubAgoraClient: AgoraAPIClient {
    // Returns mock data
}

// Factory selects appropriate client
public enum NetworkingServiceFactory {
    public static func createClient(config: AppConfig) -> AgoraAPIClient {
        if config.mockExternalServices {
            return StubAgoraClient()
        } else {
            return OpenAPIAgoraClient(config: config)
        }
    }
}
```

#### Version Control

**Commit these files:**
- ✅ `OpenAPI/agora.yaml` (spec)
- ✅ `OpenAPI/openapi-config.yaml` (config)
- ✅ `OpenAPI/VERSION.lock` (generator version)
- ✅ `Packages/Kits/Networking/Sources/Networking/Generated/*.swift` (generated code)

**Ignore these:**
- ❌ `OpenAPI/.tools/` (local generator builds)

#### CI Integration

Ensure generated code stays in sync with spec:

```bash
# In CI pipeline
agctl generate openapi
git diff --exit-code Packages/Kits/Networking/Sources/Networking/Generated
```

If diff is not empty, CI fails with message: "Generated code out of sync. Run `agctl generate openapi` and commit."

#### Package.swift Dependencies

The Networking Kit requires these dependencies:

```swift
// In Packages/Kits/Networking/Package.swift
dependencies: [
    .package(url: "https://github.com/apple/swift-openapi-runtime", from: "1.0.0"),
    .package(url: "https://github.com/apple/swift-openapi-urlsession", from: "1.0.0"),
    .package(url: "https://github.com/apple/swift-http-types", from: "1.0.0")
]
```

### Resource Management

#### App-Level Resources (`Resources/`)

```
Resources/
├── AgoraApp.swift              # Main app entry point (@main)
├── ContentView.swift           # Root SwiftUI view
├── RootView.swift              # Root TabView container
├── LoadingView.swift           # App loading state view
├── Assets.xcassets/            # App-level assets
│   ├── AppIcon.appiconset/
│   ├── AppIcon-Staging.appiconset/
│   ├── AppIcon-Dev.appiconset/
│   └── AccentColor.colorset/
├── Info.plist                  # App configuration and capabilities
├── Agora.entitlements          # App entitlements (Sign in with Apple, etc.)
└── Localizable.strings         # App-level localized strings
```

#### Package-Level Resources

Each package can include its own resources:

```
PackageName/
├── Sources/
│   └── PackageName/
│       └── Resources/              # Package-specific resources
│           ├── Assets.xcassets/
│           ├── Localizable.strings
│           └── [other resources]
└── Package.swift                   # Must declare resources in manifest
```

**In Package.swift:**

```swift
.target(
    name: "PackageName",
    dependencies: ["DesignSystem"],
    resources: [
        .process("Resources")
    ]
)
```

#### Asset Naming Conventions

- **App Icons:** `AppIcon` (production), `AppIcon-Staging`, `AppIcon-Dev`
- **Colors:** Use semantic names (e.g., `AccentColor`, `PrimaryBackground`)
- **Images:** Use descriptive names (e.g., `onboarding-welcome`, `icon-checkmark`)

### Build Automation with agctl

**Primary Tool:** Use `agctl` for all module-level operations and code generation.

#### agctl - Agora Command Line Tool

`agctl` is a Swift-based CLI tool that replaces shell scripts with a unified interface.

**Installation:**
```bash
cd Tools/agctl
./install.sh
```

**Common Commands:**
```bash
# Generate OpenAPI client (REPLACES Scripts/generate-openapi.sh)
agctl generate openapi

# Build specific modules
agctl build AuthFeature
agctl build DesignSystem

# Test specific modules
agctl test Networking
agctl test Compose

# Validate project structure
agctl validate modules
agctl validate dependencies

# Install git hooks for automatic validation
agctl install-hooks
```

**Documentation:**
- Quick Start: `Tools/agctl/QUICKSTART.md`
- Full Guide: `docs/AGCTL_GUIDE.md`
- Command Reference: `Tools/agctl/README.md`
- Built-in Help: `agctl --help`

#### Legacy Scripts (Still in use)

```
Scripts/
├── ci-postbuild.sh            # CI post-build tasks
└── run-ui-tests.sh            # UI test runner
```

**Note:** `generate-openapi.sh` and `prebuild.sh` have been replaced by `agctl` commands.

### Common Build Commands

**Using agctl (Recommended):**

```bash
# OpenAPI generation
agctl generate openapi              # Generate API client from OpenAPI spec

# Module builds
agctl build                         # Build all modules
agctl build Networking              # Build specific module
agctl build --release               # Release build

# Module tests
agctl test                          # Test all modules
agctl test Networking               # Test specific module
agctl test --parallel               # Parallel testing

# Validation
agctl validate modules              # Check module structure
agctl validate dependencies         # Check for circular deps
```

**Using xcodebuild (For main app):**

```bash
# Build staging
xcodebuild -scheme "Agora Staging" -configuration Debug-Staging

# Build production
xcodebuild -scheme "Agora Production" -configuration Release-Production

# Run UI tests
./Scripts/run-ui-tests.sh
```

### Common Configuration Tasks

#### Adding a New Environment Variable

1. **Add to both environment plists** (`Staging.plist`, `Production.plist`):
   ```xml
   <key>newConfigKey</key>
   <string>value</string>
   ```

2. **Add to example files** with fake values:
   ```xml
   <!-- Staging.plist.example -->
   <key>newConfigKey</key>
   <string>fake-value-for-testing</string>
   ```

3. **Update AppConfig struct:**
   ```swift
   public struct AppConfig: Sendable {
       // ... existing properties
       public let newConfigKey: String
   }
   ```

4. **Update AppConfig.load():**
   ```swift
   guard let newConfigKey = dict["newConfigKey"] as? String else {
       fatalError("Missing newConfigKey in plist")
   }
   ```

#### Adding a New API Endpoint

1. **Edit OpenAPI spec:**
   ```bash
   vim OpenAPI/agora.yaml
   ```

2. **Add endpoint definition:**
   ```yaml
   paths:
     /api/v1/new-endpoint:
       get:
         operationId: getNewData
         responses:
           '200':
             description: Success
   ```

3. **Generate code:**
   ```bash
   agctl generate openapi
   ```

4. **Add high-level method to AgoraAPIClient:**
   ```swift
   func fetchNewData() async throws -> NewData
   ```

5. **Implement in OpenAPIAgoraClient and StubAgoraClient**

6. **Commit changes:**
   ```bash
   git add OpenAPI/ Packages/Kits/Networking/Sources/Networking/Generated/
   git commit -m "Add new-endpoint API"
   ```

### Environment Setup for New Developers

1. **Clone repository**

2. **Install agctl:**
   ```bash
   cd Tools/agctl
   ./install.sh
   agctl install-hooks  # Install git hooks for automatic validation
   ```

3. **Copy example plists:**
   ```bash
   cp Resources/Configs/Staging.plist.example Resources/Configs/Staging.plist
   cp Resources/Configs/Production.plist.example Resources/Configs/Production.plist
   ```

4. **Fill in real values** (ask team for credentials)

5. **Install OpenAPI generator (if not using agctl):**
   ```bash
   mint install apple/swift-openapi-generator
   ```

6. **Verify setup:**
   ```bash
   agctl generate openapi    # Should succeed
   agctl validate modules    # Should pass
   agctl build              # Should build successfully
   ```

### Related Documentation

- **Project Structure:** `project-structure.mdc` - Where files go
- **Module Standards:** `module-standards.mdc` - How to create packages
- **Environment Strategy:** See `STAGING_ENVIRONMENT_STATUS.md` for environment details
- **OpenAPI Integration:** See `OpenAPI/README.md` for spec editing workflow
